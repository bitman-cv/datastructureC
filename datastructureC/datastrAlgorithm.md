# 数据结构：

## 基础概念：

###### 抽象数据类型(ADT)：

一个数学模型以及定义在该模型上的一组操作。



## 表ADT：

大小为N的表 ： A0，A1，A2，A3，……，A(N-1)。**其实就是一组数据及定义在这组数据上的操作；**一般有数组实现和链表实现；

### 链表：

#### 链表实现：

增加表头（header）或哑节点（dummy node），置于最前面；

#### 链表类型：

###### 单链表：

###### 双链表：

###### 循环链表：

#### 链表应用：

###### 多项式ADT:

###### 基数排序：

###### 多重表：

#### 游标实现：

##### 链表指针实现的两个特性：

1、数据存储在一组结构体中，每一个结构体包含有数据以及指向下一个结构体的指针；

2、一个新的结果狗提可以通过调用malloc而从系统全局内存得到，并可以通过调用free而被释放；

### 栈ADT:

栈：是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶；

对空栈进行pop、top操作一般认为是栈ADT的错误；当运行push时空间用尽时一个实现错误；

###### 栈的链表实现：

###### 栈的数组实现：

#### 栈的应用：

###### 平衡符号：

读入字符，如果字符是一个开放符号，则将其推入栈中；如果字符是一个封闭符号，则当栈空时报错，否则栈元素弹出，若弹出的符号不是对应的开放符号，则报错；到字符结束，如果栈非空，则报错；

###### 后缀表达式：

后缀式或逆波兰式；遇到一个数时就压入栈中，遇到一个运算符号时就从栈中弹出两个数进行运算，结果存入栈中；

###### 中缀转后缀表达式：

遇到字符则输出，遇到运算符号则存入栈中，如果栈顶的标点符号优先级>=新读入的运算符优先级，则先输出栈顶符号，再存入新读入的运算符号；遇到开括号"("，压入栈，遇到闭括号")"，则将栈中开括号之前的都弹出；输入全部读入以后清空栈；

###### 函数调用：

尾递归的代码可能被编译器优化，在递归时不会在栈中存储调用前的数据；尾递归可以用goto代码代替实现；

### 队列ADT:

队列是插入在一端而删除在另一端进行的表；

###### 数组实现：

###### 循环数组：

## 树：

根、树叶（没有子节点的节点）、

从节点n1到nk的路径定义为n1~nk的一个序列，这个路径的长为路径上的边的条数；

ni的深度：为从根到ni节点唯一路径的长度；

ni的高度：为从ni到一片树叶的最长路径的长；

### 数的遍历及应用：

###### 先序遍历：

先序遍历中，对节点的处理工作是在它的诸儿子节点被处理之前进行的；如：打印文件系统中所有的文件名称

###### 后序遍历：

后序遍历中，一个节点的工作是在它的诸儿子节点被计算后进行的；如：计算每个文件占用的磁盘区块的个数； 

### 二叉树：

二叉树每个节点的儿子都不能多余两个；

#### 实现：

```c
typedef struct TreeNode *PtrToNode;
typedef struct PtrToNode Tree;
struct TreeNode
{
    ElementType Element;
    Tree Left;
    Tree Right;
}
```

#### 表达式树：

属于分析树，是编译器设计中的核心数据结构；

叶子是操作数，其他节点是操作符；                

###### 中序遍历：

先左节点->根节点->右节点；

###### 构造一个棵表达式树：

把后缀表达式转换成二叉树时，读入的是数字，则将数字构造成单节点的新树，将树的指针压入栈中；当读入的是一个操作符时，从栈中弹出两个数的节点，分别作为读入操作符的左右节点（先弹出的为右节点），构造成新树，压入栈中。直至完成。

### 二叉查找树：

二叉查找树是一种查找树ADT;

**内部路径和：**一棵树的所有节点的深度和；

###### 二叉查找树的性质：

对于树中的每个关键字X，它的左子树中每个值小于关键字X，右子树中每个值大于关键字X;

###### 删除分三种情况：

​    1、删除叶子节点，直接删除；

​    2、如果节点有一个子节点，则该节点的父节点调整指针指向该节点子节点后，该节点被删除；

​    3、如果该节点有两个子节点，则找到该节点右子树中数据最小的节点的数据代替该节点的数据，然后递归的删除最小节点；

​    4、懒惰删除：当一个节点被删除时，仍留在树中，增加被删除的记号。在有重复关键字或被删除的关键字重新插入时效率高；

###### 二叉查找树时间复杂度：

平均复杂度为O(logN)。删除操作可以随机选取右子树最小元素或者左子树的最大元素代替被删除的元素以消除删除时出现的深度不平衡问题；向一颗预先排序的树输入数据，链表实现代价巨大，因为此时的树只由没有左儿子的节点组成。一种解决方法是增加一个陈伟平衡的附加的结构条件：任何节点的深度均不得过深；

### AVL树：

带有平衡条件的二叉查找树；每个节点的左子树和右子树的高度最大差1的二叉查找树；

每一个节点（在其节点结构中）保留高度信息；假设懒惰删除，则除了插入外，所有的树操作都可以以时间O(logN)执行。插入操作时，可能破坏AVL树的特性，则插入后通过**旋转**来修正。沿着插入点上行到根的路径更新平衡信息时，找到一个点，它的新平衡破坏了AVL条件；我们在第一个这样的节点重新平衡这棵树，即可保证真个树满足AVL特性。

#### 单旋转：

当在α左儿子的左子树、右儿子的右子树两种对称插入时，通过一次单旋转完成调整。找到破坏平衡的节点，进行旋转。

#### 双旋转：

当在α左儿子的右子树插入时，先左旋转再右旋转；当在α的右儿子的左子树插入时，先右旋转再左旋转；

### 伸展树：

保证从空树开始任意M次对树的操作最多话费O(M log N)时间；

#### 展开：

之子形旋转：和双旋转类似；

一字形旋转：

删除一个节点时，将该节点推倒根处，删除该节点，将得到两棵子树TL和TR；

### 树的遍历：

前序遍历：

中序遍历：

后序遍历：

层序遍历：

### B-树：

###### M阶B树的特性：

树的根或者是一片树叶，或者其儿子数再2到M之间；

除根外，所有非树叶节点的儿子数再[M/2]和M之间；

所有的树叶都在相同的深度上；

###### 删除节点：

通过查找要删除的关键字并将其除去而完成删除操作。当删除后这个节点只剩一个关键字，可以通过把和兄弟节点进行合并来调整。如果兄弟节点已经有3个关键字，则从中取出一个使得两个节点各有两个关键字；如果只有两个节点，则合并，此时父节点失去一个子节点，继续向上检查；如果根节点失去了它的第二个儿子，则删除根；

###### 插入节点：

如果接收关键字的节点已经有M个关键字了，则分裂；往上检查，如果根节点已经有M个子节点，则分裂根节点；

#### 时间效率分析：

###### 主存中：

B树的深度最多是[log~[m/2]~N]，在路径上每个节点，需要执行O(log M)时间的工作量确定选择哪个分支（使用折半查找）；每次Insert和Delete可能需要O(M)的工作量来调整该节上的所有信息。经验指出：M为3或者4时效率最好。

###### 硬盘中：

硬盘IO时间远大于B-树选择调整时间。此时M的值选择为使得一个内部节点仍然能够装入一个磁盘区块的最大值。一般来说，32<=m<=256。选择存储在片树叶上的元素的最大个数时，要使得如果树叶时满的，那么他就装满一个区块。这意味着一个记录总可以在很少的磁盘访问中被找到，因为典型的B-树只有2或3，而根（很可能还有第一层）可以放在主存中。

### 树总结：

**表达式树**是**分析树**的一个小例子，分析树是编译器设计中的核心数据结构；

**查找树**，几乎支持所有有用的操作，且其对数平均开销很小，非递归实现要快一些。但其性能严重依赖于输入，极端情况下其运行时间会显著增加，查找树会成为昂贵的链表；

**AVL树**要求所有节点的左子树和右子树的高度相差最多为1。不改变树的操作都可以使用标准二叉查找树的程序。改变树的操作必须将树恢复，特别是在删除时，较复杂；

**伸展树**中节点可以到达任意深度，但是每次访问之后树又进行调整，操作所花费的时间与平衡二叉树类似；

**B树**是平衡M-路树，能很好的匹配磁盘；

一般来说平衡树的运行时间都不如简单二叉查找树省时（相差一个常树因子），但是平衡树能够防止轻易得到最坏情形的输入。 

通过将一些元素插入到查找树然后执行一次中序遍历，得到有序序列。为一种O(N longN)的排序算法。

## 散列：

散列是一种以常熟平均时间执行插入、删除和查找的技术。但是需要元素间任何排序信息的操作将不会得到有效支持，如FindMax()、FindMin()以及以线性的时间将排序后的额整个表进行打印的操作。

### 散列函数：

将关键字映射到散列Table中某个数.

Key mod TableSize;一般TableSize选择素数；

将字符串的每个字符相加。将TableSize很大时，并不能均匀分配；

假设Key至少有两个字符外加一个NULL结束，分别以27的倍数递增。但是3个字母的不同组合实际只有2851；

对整个Key所有字符按照32的倍数递增相加；

### 散列冲解决：

#### 分离链接法：

使用一个数组作为hash，每个数组的元素是包含key的链表，冲突的时候插入到链表中。如果不用实现删除，则链表不用表头。

由于需要指针，给新单元分配地址需要时间，导致算法的速度多少有些减慢。

#### 开放定址法：

如果有冲突发生，就尝试选择另外的单元，直到找到空的单元为止。h~i~(X)=(Hash(X)+F(I)) mod TableSize。一般来说，对开放定址散列算法来说，装填因子应该低于0.5。

##### 线性探测法：

冲突函数F是线性函数。如逐个探测每个单元。花费时间多，且易发生一次聚集。如果填装因子小于0.5，平均花费时间少，之后随着填装因子增大，所花费时间显著增加。

##### 平方探测法：

冲突函数为二次函数。

**定理：**如果使用平方探测，且表的大小是素数，那么当表至少有一般是空的时候，总能够插入一个新的元素。

标准的删除操作已经不能施行，因为相应的单元可能已经引起过冲突。

平方探测排除了一次据集，但是散列到同一位置上的哪些元素将探测相同的备选单元，这叫做**二次据集**。

##### 双散列：

F(i) = i*hash~2~(X)，将第二个散列函数应用到X并在距离hash2(X)、2hash2(X)等处探测。

#### 再散列：

当表的元素填的太满，操作的运行时间开始消耗过长。此时建立另外一个大约两倍大的表（并且使用一个相关的新散列函数），扫描整个原始散列表，计算每个元素的新散列值并将其插入到新表中。

#### 可扩散列：

数据量太大装不进主存时，采用和B-树类似的原理实现。

### 散列总结：

散列表能够以常熟平均时间实现Insert和Find操作，在装填因子合适时。

散列的最坏情况一般来自于实现的缺憾，而右序的输入却可能使二叉树运行的很差。平衡查找树实现的代价相当高，因此，如果不需要序的信息以及对输入是否被排序有怀疑，那么就应该选择散列这种数据结构。

符号表：编译器使用散列表根总源代码中声明的变量。

图论：散列表对任何图论问题都是有用的。

变换表：游戏中用来通过简单移动变换来避免昂贵的重复计算。

在线拼写校验程序。

## 优先队列：

对于队列中的元素的处理不是先进先出，而是按照一定规则先出；

###### 模型：

至少允许以下两种操作的数据结构：Insert和DeleteMin。

可以采用链表实现；可以采用二叉查找树实现；可以采用平衡树实现；

### 二叉堆：

堆是一棵完全填满的二叉树。

###### 完全二叉树：

一颗完全填满的二叉树，可能的例外在底层，底层的元素从左到右填入。

可以用数组实现完全二叉树。

###### 堆序性：

根据堆序性质，最小元总可以在根处找到。因此，以常数时间完成附件运算FindMin。

###### FindMin：

插入时采用**上滤**策略，即当插入元素不能插入到新建的空穴中时，把空穴的父节点上的元素移入该空穴中，这样空穴就朝着根的方向上行一行，继续此步骤，直至空出来的位置能够放置插入元素。

###### DeleteMin：

删除最小值时采用**下滤**策略，挨个找删除节点的子节点中较小的一个移到空穴，如果子节点大于最后一个值，则将最后一个值移到空穴。

###### DecreaseKey(P, Q, H):

将P处的关键字的值降低Q,可能破坏堆的序，必须通过上滤进行调整；

###### IccreaseKey(P, Q, H):

将P处的关键字的值升高Q,可能破坏堆的序，必须通过下滤进行调整；

###### Delete(P,H):

首先执行Decrease(P, Q, H ),然后再执行DeleteMin(H)来实现；

###### BuildHeap(构建堆):

每个Insert将花费O(1)平均时间以及O(log N)的最坏情形时间；

###### 定理1：

包含2^h+1^-1个节点高为h的理想二叉树的节点的高度的和为2^h+1^-1-(h-1);

### 优先队列应用：

#### 选择问题：

输入N个元素以及一个整数k，找出第k个最大的元素；

**算法一：**

把这些元素读入数组并将他们排序，返回适当的元素。使用简单排序算法,则为O(N^2^);

**算法二：**

将k个元素读入数组并排序，最小值在k上；新读入的数先和k第k个元素比较，如果该元素大，则用新元素替换第k个元素，进行排序，直到所有元素读入。为O(N•k)。如果k = N/2,则该算法也为O(N^2^);

**算法三：**

将N个元素读入一个数组，对该数组应用BuildHeap算法，最后执行k次DeleteMin操作，最后提取的元素；即堆排序；

**算法四：**

采用算法1类似的思想，用小顶堆实现，时间未O(Nlogk)；

#### 事件模拟：

### d-堆：

d-堆是二叉堆的简单推广，它所有节点都有d个儿子。则二叉堆是2-堆；

### 左式堆：

左式堆具有相同的堆序性质；左式堆和二叉树间唯一的区别是：左式堆不是理想平衡的。

**性质：**对于堆中的每一个节点X,左儿子的零路径长至少与右儿子的零路径长一样大；

##### 零路径长：

从节点到一个没有两个儿子的节点的额最短路径的长；NULL的为-1；

###### 定理2：

在右路径上右r个节点的左式数必然至少右2^r^-1个节点

###### Merge:

1、递归的将具有大的根值的堆与具有小的根值的堆的右子堆合并。如果发现待合并的堆的左子堆为NULL，则直接将要合并的堆为左子堆，递归进行；

2、合并完成比较左右子堆的零路径长，如果右子堆的零路径大于左子堆，则交换两个子堆；

3、调整根节点的零路径长；

```c
struct TreeNode
{
    ElementType Element;
    PriorityQueue Left;
    PriorityQueue Right;
    int Npl;
}

PriorityQueue Merge(PriorityQueue H1, PriorityQueue H2)
{
    if(H1 == NULL){
        return H2;
    }
    if(H2 == NULL){
        return H1;
    }
    if(H1->Element < H2->Element){
        return Merge1(H1, H2);
    }else{
        return Merge1(H2, H1);
    }
}

static PriorityQueue Merge1(PriorityQueue H1, PriorityQueue H2)
{
    if(H1->left == NULL){
        /*Single node,H1->Right is already NULL, H1->Npl is already 0*/
        H1->Left = H2;
    }else{
        H1->Right = Merge(H1->Right, H2);
        if(H1->Left->Npl < H1->Right->Npl){
            SwapChildren(H1);
        }

        H1->Npl = H1->Right->Npl + 1;
    }
    return H1;
}
```

### 斜堆：

斜堆是左式堆的自调节形式；斜对是具有堆序的二叉树，但是不存在对数的结构限制；关于任意节点的零路径长的信息都不保留。斜堆的右路径可以任意长，所有操作的最坏情形运行时间都是O(N)；然而正如伸展树一样，对于任意M次连续操作，总的最坏情形运行时间是O(M logN)；

斜堆和左式堆间的关系类似于伸展树和AVL树间的关系；

### 二项队列：

一个二项队列不是一棵堆序的树，而是堆序树的集合，称为森林；堆序树中的每一棵都是有约束的形式，叫做二项树；每一个高度上至多存在一棵二项树；在高度d出的节点数是二项系数；

###### Merge:

搜索最小元可以通过搜索所有树地根找出。由于最多有logN棵不同地树，因此最小元可以试间O(log N)找到；

合并操作基本上是通过将两个队列加到一起来完成地；

###### Insert：

插入其实就是特殊情形地合并，通过创建一棵单节点树并执行一次合并完成；

###### DeleteMin：

首先找到一棵具有最小根的二项树，除过这棵树其他的树组成一个优先队列，去掉这课树的树根生成一个优先队列；两个优先队列合并成一个优先队列；

























​	      

















# 算法：

## 时间复杂度评估：

### 语句时间复杂度法则：

###### FOR循环：

一次for循环的运行时间至多是该for循环内语句的运行时间乘以迭代的次数；

###### 嵌套FOR:

从内到外分析。一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间诚意该组所有的for循环的大小的乘积；

###### 顺序语句：

各个语句的运行时间求和即可；

###### IF/ELSE语句：

一个if/else语句的运行时间从不超过判断再加上S1和S2中运行时间长者的总的运行时间；

## 基础概念：

###### 联机算法：

联机算法是在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。

###### 离线算法：

在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法( off line algorithms)。



## 技巧：

###### 对数时间：

如果一个算法用常数时间将我呢提的大小削减为其一部分，则为O(logN)；

## 排序：

| 类别     | 排序方法  | 时复(aver) | 时复(best) | 时复(worst) | 空间复杂度 | 稳定性 |
| -------- | --------- | ---------- | ---------- | ----------- | ---------- | ------ |
| 插入排序 | 插入排序  | O(N^2^)    | O(N)       | O(N^2^)     | O(1)       | 稳定   |
|          | shell排序 | O(N^1.3^)  | O(N)       | O(N^2^)     | O(1)       | 不稳定 |
| 选择排序 | 选择排序  | O(N^2^)    | O(N^2^)    | O(N^2^)     | O(1)       | 不稳定 |
|          | 堆排序    | O(N*lgN)   | O(N*lgN)   | O(N*lgN)    | O(1)       | 不稳定 |
| 交换排序 | 冒泡排序  | O(N^2^)    | O(N)       | O(N^2^)     | O(1)       | 稳定   |
|          | 快速排序  | O(N*lgN)   | O(N*lgN)   | O(N^2^)     | O(lgN)     | 不稳定 |
| 归并排序 | 归并排序  | O(N*lgN)   | O(N*lgN)   | O(N*lgN)    | O(N)       | 稳定   |

###### 直接插入排序(Insertion sort):

从第一个元素开始,该元素已经排好序,继续取元素与排好序的元素依次进行比较,升序的话插入到比前一个大比后一个小的位置,然后重复上述步骤,直到插完元素为止;

**定理1：**N个互异数的数组的平均逆序数是N(N-1)/4；

**定理2：**通过交换相邻元素进行排序的任何算法平均需要Ω(N^2^)试间；

###### 希尔排序(Shell sort):

对整个待排序序列进行分组,然后对每一组进行直接插入排序;

**定理3：**使用希尔增量时希尔排序的最坏情形运行试间为Θ(N^2^)；

**定理4：**使用Hibbard增量的希尔排序的最坏情形运行试间为Θ(N^3/2^)；

h~k~排序的数组在h~k-1~排序中将保持它的h~k~排序特性；

###### 堆排序(Heap sort):

若升序的话,就将堆调成一个大堆,若降序的话,就将堆调成一个小堆.从倒数第一个非叶子节点开始往根遍历,若当前节点的值都大于左右孩子,则不用动,若是小于,就将左右孩子当中最大的节点与当前节点交换,交换后就需要进行向下调整(因为交换会影响大堆结构).重复上述步骤,直到根节点为止;

**定理5：**堆N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN);

###### 归并排序(Merge Sort):

将待排序的元素序hebing 列分为两个长度相等的子序列,对每个子序列进行排序,然后将他们合并成一个序列,合并两个子序列的过程称为二路归并;

分治是递归非常有效的用法；

归并排序的运行时间是O(NlogN)，但是它很难用于主存排序，主要问题在于合并两个排序的表需要线性附件内存；还要花费时间将数据拷贝到临时数组再拷贝回来，严重放慢了速度。

###### 冒泡排序：

（Bubble Sort）：比较两个相邻的元素,如果升序的话,前面的比后面的大,就交换,这样一轮下来,就会找到这组数据中最大的元素,然后抛开这个元素继续重复上述步骤.知道排完为止;

###### 快速排序（Quick Sort):

任取待排序中的某一元素作为基准值,按照该排序码,将待排序集合分割成两个子序列,左边的序列比基准值小,右边的比基准值大.然后对左右子序列重复上述步骤.直到排完为止;



###### 直接选择排序(Straight Select Sorting):

在未排序的序列中找到最小的元素,存放到序列的首位置,找到最大的元素存放到序列的末尾.然后抛开首位和末尾,继续重复该步骤,直到排完为止;





